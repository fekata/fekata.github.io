<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[音乐与图片Test]]></title>
      <url>%2F2017%2F02%2F11%2FimageTest%2F</url>
      <content type="text"><![CDATA[音乐测试 图片测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[精一行，必先通十行]]></title>
      <url>%2F2017%2F02%2F11%2F%E7%B2%BE%E4%B8%80%E8%A1%8C%E5%BF%85%E5%85%88%E9%80%9A%E5%8D%81%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[融合的优势在于任何一方面能力的发挥都会有其他几方面去辅助它，从而比那些只专注一方面的人要来的更有竞争力。 全栈工程师，也叫全端工程师(同时具备前端和后台能力)，是指掌握多种技能，并能利用多种技能独立完成产品的人；现代项目的开发，需要掌握多种技术。互联网项目，需要用到后端开发、前端开发、界面设计、产品设计、数据库、各种移动客户端、三屏兼容、restFul API设计和 OAuth 等等，比较前卫的项目，还会用到 SPA、Web Socket、HTML5/CSS3 这些技术以及像第三方开发像微信公众号微博应用等等。 简而言之，全栈工程师（全端工程师）= 前端 + 后端 + 数据库 + IOS App + Andriod App + 界面设计 + 产品设计 + 用户体验等。 所以，2017年，继续默默努力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KATA JavaScript Library v1.0]]></title>
      <url>%2F2017%2F02%2F10%2FKATA%20JavaScript%20Library%20v1.0%2F</url>
      <content type="text"><![CDATA[工具库一些实用的小功能，慢慢完善。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214/* * KATA JavaScript Library v1.0 * Copyright (c) 2017 www.chenfangka.com */(function(window) &#123; var k = &#123;&#125;; //获取 url 中的参数 k.getQueryString = function(name) &#123; var reg = new RegExp("(^|&amp;amp;)" + name + "=([^&amp;amp;]*)(&amp;amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return decodeURI(r[2]); &#125; else &#123; return null; &#125; &#125;; //获取数组中的最大值 k.arrayMax = function(array) &#123; return Math.min.apply(Math, array); &#125; //获取数组中的最小值 k.arrayMin = function(array) &#123; return Math.max.apply(Math, array); &#125; //清除前后空格 k.trim = function(str) &#123; if (String.prototype.trim) &#123; return str == null ? "" : String.prototype.trim.call(str); &#125; else &#123; return str.replace(/(^\s*)|(\s*$)/g, ""); &#125; &#125;; //清除所有空格 k.trimAll = function(str) &#123; return str.replace(/\s*/g, ''); &#125;; //判断是否是元素节点 k.isElement = function(obj) &#123; return !!(obj &amp;&amp; obj.nodeType == 1); &#125;; //判断是非是数组 k.isArray = function(obj) &#123; if (Array.isArray) &#123; return Array.isArray(obj); &#125; else &#123; return obj instanceof Array; &#125; &#125;; //判断是否为空对象 k.isEmptyObject = function(obj) &#123; if (JSON.stringify(obj) === '&#123;&#125;') &#123; return true; &#125; return false; &#125;; //检查对象集合中是否有元素含有指定的class k.hasCls = function(el, cls) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.hasCls Function need el param, el param must be DOM Element'); return; &#125; if (el.className.indexOf(cls) &gt; -1) &#123; return true; &#125; else &#123; return false; &#125; &#125;; //为元素添加指定的class类名 k.addCls = function(el, cls) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.addCls Function need el param, el param must be DOM Element'); return; &#125; if ('classList' in el) &#123; el.classList.add(cls); &#125; else &#123; var preCls = el.className; var newCls = preCls + ' ' + cls; el.className = newCls; &#125; return el; &#125;; //移除当前对象集合中所有元素的指定class k.removeCls = function(el, cls) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.removeCls Function need el param, el param must be DOM Element'); return; &#125; if ('classList' in el) &#123; el.classList.remove(cls); &#125; else &#123; var preCls = el.className; var newCls = preCls.replace(cls, ''); el.className = newCls; &#125; return el; &#125;; //在匹配的元素集合中的每个元素上添加或删除一个或多个样式类。如果class的名称存在则删除它，如果不存在，就添加它。 k.toggleCls = function(el, cls) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.toggleCls Function need el param, el param must be DOM Element'); return; &#125; if ('classList' in el) &#123; el.classList.toggle(cls); &#125; else &#123; if (k.hasCls(el, cls)) &#123; k.removeCls(el, cls); &#125; else &#123; k.addCls(el, cls); &#125; &#125; return el; &#125;; //插入元素，位置如下 // &lt;!-- before --&gt; // &lt;p&gt; // &lt;!-- prepend --&gt; // foo // &lt;!-- append --&gt; // &lt;/p&gt; // &lt;!-- after --&gt; k.before = function(el, html) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.before Function need el param, el param must be DOM Element'); return; &#125; if (k.isElement(html)) &#123; el.insertAdjacentElement('beforebegin', html); &#125; else &#123; el.insertAdjacentHTML('beforebegin', html); &#125; return el; &#125;; k.prepend = function(el, html) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.prepend Function need el param, el param must be DOM Element'); return; &#125; if (k.isElement(html)) &#123; el.insertAdjacentElement('afterbegin', html); &#125; else &#123; el.insertAdjacentHTML('afterbegin', html); &#125; return el; &#125;; k.append = function(el, html) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.append Function need el param, el param must be DOM Element'); return; &#125; if (k.isElement(html)) &#123; el.insertAdjacentElement('beforeend', html); &#125; else &#123; el.insertAdjacentHTML('beforeend', html); &#125; return el; &#125;; k.after = function(el, html) &#123; if (!k.isElement(el)) &#123; console.warn('$kata.after Function need el param, el param must be DOM Element'); return; &#125; if (k.isElement(html)) &#123; el.insertAdjacentElement('afterend', html); &#125; else &#123; el.insertAdjacentHTML('afterend', html); &#125; return el; &#125;; //JSON转字符 k.jsonToStr = function(json) &#123; if (typeof json === 'object') &#123; return JSON &amp;&amp; JSON.stringify(json); &#125; &#125;; //字符转JOSN k.strToJson = function(str) &#123; if (typeof str === 'string') &#123; return JSON &amp;&amp; JSON.parse(str); &#125; &#125;; //从最大最小值中返回一个随机数 k.random = function(min, max) &#123; if (max == null) &#123; max = min; min = 0; &#125; return min + Math.floor(Math.random() * (max - min + 1)); &#125;; //获取当前时间 k.now = Date.now || function() &#123; return new Date().getTime(); &#125;; window.$kata = k;&#125;)(window);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《你不知道的JavaScript 上卷》 笔记一]]></title>
      <url>%2F2017%2F02%2F08%2F%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%20%E4%B8%8A%E5%8D%B7%E3%80%8B%20%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[1.作用域作用域是根据名称查找变量的一套规则。当一个块或函数嵌套在另一个块或函数中时，就会发生作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。 LHS和RHS的区别据不可靠资料以及自己的理解，LHS是”left hand side”的简写，RHS是”right hand side”的简写。 如果目的是获取变量的值，就会使用RHS查询。如果RHS查询在所有嵌套的作用域中找不到所需的变量，引擎就会跑出ReferenceError异常。 如果查找的目的是对变量进行赋值，那么就会使用LHS查询。 当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是非“严格模式”下。 不，这个变量之前并不存在，但是我很热心地帮你创建了一个。 ReferenceError与TypeError的区别 ReferenceError同作用域判别失败相关。 TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性，那么引擎就会抛出这一类型的异常。 JavaScript引擎首先会在代码执行前对其进行编译在这个过程中，像var a = 2;这样的声明会被分解成两个独立的步骤： 首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 接下来，a = 2;会在查询（LHS查询）变量a并对其进行赋值。 2.词法作用域词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况是这样的）。 考虑以下代码： 1234567891011function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); // 2, 4, 12 在这个例子中有三个逐级嵌套的作用域。 气泡1包含着整个全局作用域，其中只有一个标识符：foo。 气泡2包含着foo所创建的作用域，其中有三个标识符：a、bar和b。 气泡3包含着bar所创建的作用域，其中只有一个标识符：c。 3.函数作用域和块作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围使用以及复用（事实上在嵌套的作用域中也可以使用）。 最小特权原则这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。 全局命名空间在全局作用域中声明一个名字足够 独特 的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 4.提升作用域中的所有声明（变量和函数）都会被“移动”到各自作用域的最顶端（函数优先于变量）。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 5.作用域闭包当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。代码片段一： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); //2 &#125; bar();&#125;foo(); 代码片段二： 12345678910function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); //2 代码片段三： 12345678910111213function foo() &#123; var a = 2; function baz() &#123; console.log(a); //2 &#125; bar(baz);&#125;function bar(fn) &#123; fn();&#125;foo(); 代码片段四： 12345678910111213141516var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a); &#125; fn = baz; //将baz分配给全局变量&#125;function bar() &#123; fn();&#125;foo();bar(); //2 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 模块一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块.模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 模块： 12345678910111213141516171819function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join("!")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;&#125;var foo = CoolModule();foo.doSomething();foo.doAnother(); 单例模式： 12345678910111213141516171819var foo = (function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join("!")); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;&#125;)();foo.doSomething();foo.doAnother(); 接收参数 1234567891011121314function CoolModule(id) &#123; function identify() &#123; console.log(id); &#125; return &#123; identify: identify &#125;;&#125;var foo1 = CoolModule("foo 1");var foo2 = CoolModule("foo 2");foo1.identify(); //"foo 1"foo2.identify(); //"foo 2" 通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性以及修改它们的值。 12345678910111213141516171819202122232425var foo = (function CoolModule(id) &#123; function change() &#123; //修改公共API publicAPI.identify = identify2; &#125; function identify1() &#123; console.log(id); &#125; function identify2() &#123; console.log(id.toUpperCase()); &#125; var publicAPI = &#123; change: change, identify: identify1 &#125;; return publicAPI;&#125;)("foo module");foo.identify(); //"foo module"foo.change();foo.identify(); //"FOO MODULE"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F08%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
